/****************************************************************
******** Language : C *******************************************
************** OS : Windows ************************************
*********************** IDE : Dev C++  and  VScode **************
********************************** Let's start! ********************
******************************************************************/

// # 6. 난수 생성 및 숫자 맞추기 게임

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

int main()
{
	int i,cnt,guess;
	srand((unsigned int)time(NULL));
	
	printf("기회 몇번 드릴까? : ");
	scanf_s("%d",&cnt);
	
	for (i=1; i<=cnt; i++)
	{	
		int computer = rand()%100+1;
		printf("[%d/%d]Guess the correct number! : ",i,cnt);
		scanf_s("%d",&guess);
		
		if (guess==computer)
		{
			printf("Congratz!! correct!\n");
			break;
		}
		
		else if (guess>computer)
		{
			printf("더 낮은 숫자 불러봐요! 기회는 이제 %d번 남았습니다. \n",5-i);
		}
		
		else if (guess<computer)
		{
			printf("더 높은 숫자 불러봐요! 기회는 이제 %d번 남았습니다. \n",5-i);
		}
	}
	
	return 0;
}

--------------------------------------------------------------------------------------------

- 새로운 헤더파일 stdlib.h과 time.h
§ 두 헤더파일은 난수를 생성하는 함수들을 담고 있는 표준 헤더파일입니다. 정확히 따지자면 위에 보이는 소스코드 중에서 srand, rand같은 함수는 stdlib.h 헤더파일에 존재합니다.
근데 time.h를 선언하지 않는다면 처음에 생성한 난수가 변하지 않고 실행 시 그대로 남게 됩니다.
이게 무슨 말이냐면요. rand로 생성한 숫자가 77이라 합시다. 우리는 숫자 맞추기 게임을 하러 온건데 77이라는 정답이 고정이 된 겁니다.
첫번째 판도 답이 77 , 두번째 판도 답이 77 , 세번째 판도 답이 77.... 이런 식이 됩니다.
그래서 이를 방지해주는 헤더파일이 time.h입니다. 

물론 이 두가지 헤더파일이 한가지 함수만 담고 있는건 절대 아니지만 이번 글에서는 stdlib은 난수생성을 time은 중복방지를 담당한다고 보시면 되겠습니다.

--------------------------------------------------------------------------------------------

- srand((unsigned int)time(NULL)) ?? rand()%100+1 ??
§ 처음보면 당최 이게 뭔말인가? 싶은게 보입니다. srand는 앞에 s는 seed를 의미합니다.
즉, srand()함수는 rand()라는 함수에 무작위의 시드값을 주기위한 함수이며 그 파라미터로 time(NULL)이라는 매개변수를 전달합니다. 
time(NULL)은 1970년 1월 1일 이후 경과된 시간을 초 단위로 반환하는 함수입니다. 1970년에 뭐가 있었는진 모르겠지만 B언어를 개발했다라고 나와있네요.

§ rand()%100+1은 srand를 통해 시드값을 세팅한 것을 토대로 1부터 100까지 범위 안에서 무작위로 숫자를 하나 뽑으라는 말입니다. 
100이라는 것은 100개의 숫자를 의미하는데, 뒤에서 배열을 다룰 때 다시 언급하겠지만  프로그래밍에서 배열의 시작 index는 0입니다. 즉, 0부터 99까지의 범위였는데
뒤에 +1을 해줌으로써 Upper Limit, Lower Limit을 1씩 올립니다. 마찬가지로 -1을 하면 -1부터 98까지의 범위를 갖게 되겠죠?
